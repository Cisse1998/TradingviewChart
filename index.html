<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Digits Analyzer</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --background: 15 15 15;
      --card: 26 26 26;
      --secondary: 38 38 38;
      --border: 51 51 51;
      --primary: 59 130 246;
      --destructive: 239 68 68;
      --profit: 16 185 129;
      --loss: 239 68 68;
      --highlight: 245 158 11;
      --accent: 139 92 246;
      --foreground: 255 255 255;
      --muted-foreground: 161 161 170;
    }

    /* Light theme overrides */
    body.light-theme {
      --background: 248 250 252;
      --card: 255 255 255;
      --secondary: 241 245 249;
      --border: 226 232 240;
      --primary: 37 99 235;
      --destructive: 220 38 38;
      --profit: 22 163 74;
      --loss: 220 38 38;
      --highlight: 245 158 11;
      --accent: 139 92 246;
      --foreground: 15 23 42;
      --muted-foreground: 71 85 105;
    }

    body { 
      background-color: rgb(var(--background)); 
      color: rgb(var(--foreground)); 
      font-family: ui-monospace, monospace; 
      transition: background-color 0.2s, color 0.2s;
    }
    .bg-background { background-color: rgb(var(--background)); }
    .bg-card { background-color: rgb(var(--card)); }
    .bg-secondary { background-color: rgb(var(--secondary)); }
    .bg-primary { background-color: rgb(var(--primary)); }
    .bg-destructive { background-color: rgb(var(--destructive)); }
    .bg-profit { background-color: rgb(var(--profit)); }
    .bg-loss { background-color: rgb(var(--loss)); }
    .bg-highlight { background-color: rgb(var(--highlight)); }
    .bg-accent { background-color: rgb(var(--accent)); }
    .border-border { border-color: rgb(var(--border)); }
    .text-foreground { color: rgb(var(--foreground)); }
    .text-muted-foreground { color: rgb(var(--muted-foreground)); }
    .text-primary { color: rgb(var(--primary)); }
    .text-profit { color: rgb(var(--profit)); }
    .text-loss { color: rgb(var(--loss)); }
    .text-highlight { color: rgb(var(--highlight)); }
    .text-accent { color: rgb(var(--accent)); }
    .animate-pulse-glow {
      animation: pulse-glow 1.5s ease-in-out infinite;
    }
    @keyframes pulse-glow {
      0%, 100% { opacity: 1; text-shadow: 0 0 5px rgb(var(--profit)); }
      50% { opacity: 0.5; text-shadow: 0 0 12px rgb(var(--profit)); }
    }
    .font-mono { font-family: 'Menlo', 'Courier New', monospace; }
  </style>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-background">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useMemo, useCallback, useEffect, useRef } = React;

    // ---------- constants ----------
    const DERIV_WS_URL = "wss://ws.binaryws.com/websockets/v3?app_id=1089";
    const VOLATILITY_SYMBOLS = [
      // Jump Indices
      { value: "JD10", label: "Jump 10 Index" },
      { value: "JD25", label: "Jump 25 Index" },
      { value: "JD50", label: "Jump 50 Index" },
      { value: "JD75", label: "Jump 75 Index" },
      { value: "JD100", label: "Jump 100 Index" },
      // Volatility Indices
      { value: "R_10", label: "Volatility 10 Index" },
      { value: "R_25", label: "Volatility 25 Index" },
      { value: "R_50", label: "Volatility 50 Index" },
      { value: "R_75", label: "Volatility 75 Index" },
      { value: "R_100", label: "Volatility 100 Index" },
      // Volatility Indices (1s)
      { value: "1HZ10V", label: "Volatility 10 (1s) Index" },
      { value: "1HZ15V", label: "Volatility 15 (1s) Index" },
      { value: "1HZ25V", label: "Volatility 25 (1s) Index" },
      { value: "1HZ30V", label: "Volatility 30 (1s) Index" },
      { value: "1HZ50V", label: "Volatility 50 (1s) Index" },
      { value: "1HZ75V", label: "Volatility 75 (1s) Index" },
      { value: "1HZ90V", label: "Volatility 90 (1s) Index" },
      { value: "1HZ100V", label: "Volatility 100 (1s) Index" },
    ];

    // Fallback decimal places based on your examples (if API fails)
    const DECIMAL_FALLBACK = {
      '1HZ10V': 2,
      'R_10': 3,
      '1HZ15V': 3,
      '1HZ25V': 2,
      'R_25': 3,
      '1HZ30V': 3,
      '1HZ50V': 2,
      'R_50': 4,
      '1HZ75V': 2,
      'R_75': 4,
      '1HZ90V': 3,
      '1HZ100V': 2,
      'R_100': 2,
      'JD10': 2,
      'JD25': 2,
      'JD50': 2,
      'JD75': 2,
      'JD100': 2,
    };

    // ---------- helper: extract last digit from a formatted price string ----------
    function getLastDigitFromPrice(priceStr) {
      const dotIndex = priceStr.indexOf('.');
      if (dotIndex === -1) {
        return parseInt(priceStr.slice(-1), 10);
      } else {
        const decimalPart = priceStr.slice(dotIndex + 1);
        return parseInt(decimalPart.slice(-1), 10);
      }
    }

    // ---------- fetch symbol details to get decimal places ----------
    async function fetchDecimalPlaces(symbol) {
      try {
        const response = await fetch(`https://api.deriv.com/api/v3/symbols?symbols=${symbol}&app_id=1089`);
        const data = await response.json();
        if (data.symbols && data.symbols[0]) {
          const info = data.symbols[0];
          if (info.decimal_places !== undefined) {
            return info.decimal_places;
          } else if (info.pip_size) {
            return Math.round(Math.log10(1 / info.pip_size));
          }
        }
      } catch (e) {
        console.error("Failed to fetch symbol details", e);
      }
      return DECIMAL_FALLBACK[symbol] || 3;
    }

    // ---------- websocket (passes raw price number) ----------
    function connectDeriv() {
      let ws = null;
      let subscriptionId = null;

      const subscribe = (symbol, onTick) => {
        if (ws) ws.close();

        ws = new WebSocket(DERIV_WS_URL);

        ws.onopen = () => {
          ws?.send(JSON.stringify({ ticks: symbol, subscribe: 1 }));
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.tick) {
              subscriptionId = data.tick.id;
              const rawPrice = data.tick.quote;
              onTick(rawPrice);
            }
          } catch (e) { }
        };

        ws.onerror = () => {
          console.error("Deriv WebSocket error");
        };
      };

      const unsubscribe = () => {
        if (ws && subscriptionId) {
          ws.send(JSON.stringify({ forget: subscriptionId }));
          subscriptionId = null;
        }
      };

      const disconnect = () => {
        unsubscribe();
        if (ws) {
          ws.close();
          ws = null;
        }
      };

      return { subscribe, unsubscribe, disconnect };
    }

    // ---------- analysis functions (now using last 1000 ticks) ----------
    function computeDigitFrequency(digits) {
      const total = digits.length;
      const counts = Array(10).fill(0);
      digits.forEach(d => counts[d]++);
      return counts.map((count, digit) => ({ digit, count, percentage: total > 0 ? (count / total) * 100 : 0 }));
    }

    // compute frequency for last 1000 ticks
    function computeFrequency1000(digits) {
      const len = digits.length;
      if (len === 0) return [];
      const recent = len <= 1000 ? digits : digits.slice(len - 1000);
      const counts = Array(10).fill(0);
      recent.forEach(d => counts[d]++);
      const total = recent.length;
      return counts.map((count, digit) => ({ digit, count, percentage: (count / total) * 100 }));
    }

    function computeOverUnder(digits) {
      const total = digits.length;
      return Array.from({ length: 10 }, (_, target) => {
        const overCount = digits.filter(d => d > target).length;
        const underCount = digits.filter(d => d < target).length;
        return { digit: target, overCount, overPercentage: total > 0 ? (overCount / total) * 100 : 0, underCount, underPercentage: total > 0 ? (underCount / total) * 100 : 0 };
      });
    }
    function computeMatchDiffer(digits) {
      const total = digits.length;
      return Array.from({ length: 10 }, (_, target) => {
        const matchCount = digits.filter(d => d === target).length;
        return { digit: target, matchCount, matchPercentage: total > 0 ? (matchCount / total) * 100 : 0, differCount: total - matchCount, differPercentage: total > 0 ? ((total - matchCount) / total) * 100 : 0 };
      });
    }
    function computeEvenOdd(digits) {
      const total = digits.length;
      const evenCount = digits.filter(d => d % 2 === 0).length;
      return { evenCount, evenPercentage: total > 0 ? (evenCount / total) * 100 : 0, oddCount: total - evenCount, oddPercentage: total > 0 ? ((total - evenCount) / total) * 100 : 0 };
    }

    // Rise/Fall analysis
    function computeRiseFall(prices) {
      if (prices.length < 2) return { riseCount: 0, fallCount: 0, sameCount: 0, totalMovements: 0, risePercent: 0, fallPercent: 0 };
      let rise = 0, fall = 0, same = 0;
      for (let i = 1; i < prices.length; i++) {
        const prev = prices[i-1];
        const curr = prices[i];
        if (curr > prev) rise++;
        else if (curr < prev) fall++;
        else same++;
      }
      const total = rise + fall + same;
      return {
        riseCount: rise,
        fallCount: fall,
        sameCount: same,
        totalMovements: total,
        risePercent: total > 0 ? (rise / total) * 100 : 0,
        fallPercent: total > 0 ? (fall / total) * 100 : 0,
        samePercent: total > 0 ? (same / total) * 100 : 0
      };
    }

    // ---------- components ----------
    function AnalysisCard({ title, subtitle, children }) {
      return (
        <div className="bg-card border border-border rounded-lg p-5">
          <div className="mb-4"><h3 className="font-semibold text-foreground text-sm uppercase tracking-wider">{title}</h3>{subtitle && <p className="text-muted-foreground text-xs mt-1">{subtitle}</p>}</div>
          {children}
        </div>
      );
    }

    // DigitCircle with arc inside
    function DigitCircle({ digit, percentage, isHighest, isLowest, isCurrent }) {
      return (
        <div className="flex flex-col items-center mx-1">
          <div className="relative w-16 h-16">
            <div className="absolute inset-0 rounded-full border-4 border-border bg-secondary"></div>
            {isHighest && <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 w-6 h-1 bg-profit rounded-full z-0"></div>}
            {isLowest && <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 w-6 h-1 bg-loss rounded-full z-0"></div>}
            <div className="absolute inset-0 flex flex-col items-center justify-center z-10">
              <span className="text-xl font-bold">{digit}</span>
              <span className="text-xs">{percentage.toFixed(1)}%</span>
            </div>
          </div>
          {isCurrent && (
            <div className="text-foreground text-sm leading-3 mt-1">‚ñ≤</div>
          )}
          {!isCurrent && <div className="h-4" />}
        </div>
      );
    }

    function EvenOddDisplay({ data }) {
      return (
        <div className="flex gap-4">
          <div className="flex-1 bg-secondary rounded-lg p-4 text-center"><div className="text-xs text-muted-foreground uppercase tracking-wider mb-2">Even</div><div className="font-mono text-2xl font-bold text-profit">{data.evenPercentage.toFixed(1)}%</div><div className="text-xs text-muted-foreground mt-1">{data.evenCount} ticks</div></div>
          <div className="flex-1 bg-secondary rounded-lg p-4 text-center"><div className="text-xs text-muted-foreground uppercase tracking-wider mb-2">Odd</div><div className="font-mono text-2xl font-bold text-loss">{data.oddPercentage.toFixed(1)}%</div><div className="text-xs text-muted-foreground mt-1">{data.oddCount} ticks</div></div>
        </div>
      );
    }

    function OverUnderTable({ data }) {
      return (
        <div className="overflow-x-auto"><table className="w-full text-sm font-mono"><thead><tr className="text-muted-foreground text-xs uppercase tracking-wider"><th className="text-left py-2 px-2">Digit</th><th className="text-right py-2 px-2">Over %</th><th className="text-right py-2 px-2">Under %</th></tr></thead><tbody>{data.map(row => (<tr key={row.digit} className="border-t border-border hover:bg-secondary/50 transition-colors"><td className="py-2 px-2 font-semibold">{row.digit}</td><td className="py-2 px-2 text-right text-profit">{row.overPercentage.toFixed(1)}%</td><td className="py-2 px-2 text-right text-loss">{row.underPercentage.toFixed(1)}%</td></tr>))}</tbody></table></div>
      );
    }

    function MatchDifferTable({ data }) {
      return (
        <div className="overflow-x-auto"><table className="w-full text-sm font-mono"><thead><tr className="text-muted-foreground text-xs uppercase tracking-wider"><th className="text-left py-2 px-2">Digit</th><th className="text-right py-2 px-2">Matches %</th><th className="text-right py-2 px-2">Differs %</th></tr></thead><tbody>{data.map(row => (<tr key={row.digit} className="border-t border-border hover:bg-secondary/50 transition-colors"><td className="py-2 px-2 font-semibold">{row.digit}</td><td className="py-2 px-2 text-right text-highlight">{row.matchPercentage.toFixed(1)}%</td><td className="py-2 px-2 text-right text-accent">{row.differPercentage.toFixed(1)}%</td></tr>))}</tbody></table></div>
      );
    }

    // Rise/Fall Card
    function RiseFallCard({ data }) {
      return (
        <AnalysisCard title="üìä Rise / Fall Analysis" subtitle="Tick-to-tick price movement">
          <div className="flex gap-4">
            <div className="flex-1 bg-secondary rounded-lg p-4 text-center">
              <div className="text-xs text-muted-foreground uppercase tracking-wider mb-2">Rise</div>
              <div className="font-mono text-2xl font-bold text-profit">{data.risePercent.toFixed(1)}%</div>
              <div className="text-xs text-muted-foreground mt-1">{data.riseCount} ticks</div>
            </div>
            <div className="flex-1 bg-secondary rounded-lg p-4 text-center">
              <div className="text-xs text-muted-foreground uppercase tracking-wider mb-2">Fall</div>
              <div className="font-mono text-2xl font-bold text-loss">{data.fallPercent.toFixed(1)}%</div>
              <div className="text-xs text-muted-foreground mt-1">{data.fallCount} ticks</div>
            </div>
            {data.sameCount > 0 && (
              <div className="flex-1 bg-secondary rounded-lg p-4 text-center">
                <div className="text-xs text-muted-foreground uppercase tracking-wider mb-2">Same</div>
                <div className="font-mono text-2xl font-bold text-muted-foreground">{data.samePercent.toFixed(1)}%</div>
                <div className="text-xs text-muted-foreground mt-1">{data.sameCount} ticks</div>
              </div>
            )}
          </div>
        </AnalysisCard>
      );
    }

    // ---------- trading suggestions card (uses last 1000 ticks) ----------
    function SuggestionCard({ frequency }) {
      if (!frequency || frequency.length === 0) return null;
      const deviations = frequency.map(f => ({ digit: f.digit, dev: f.percentage - 10 }));
      const sorted = [...deviations].sort((a, b) => Math.abs(b.dev) - Math.abs(a.dev));
      const topOver = sorted.filter(d => d.dev > 0).slice(0, 3);
      const topUnder = sorted.filter(d => d.dev < 0).slice(0, 3);

      return (
        <AnalysisCard title="üìà Trading Suggestions" subtitle="Digits deviating most from 10% (last 1000 ticks)">
          <div className="flex flex-wrap gap-6">
            <div className="flex-1 min-w-[200px]">
              <h4 className="text-xs uppercase tracking-wider text-profit mb-2">üî¥ Overrepresented (may sell)</h4>
              {topOver.length === 0 ? <p className="text-muted-foreground text-sm">None</p> : 
                topOver.map(d => <div key={d.digit} className="flex justify-between items-center text-sm py-1 border-b border-border/50"><span className="font-mono">Digit {d.digit}</span><span className="text-profit font-mono">+{d.dev.toFixed(1)}%</span></div>)}
            </div>
            <div className="flex-1 min-w-[200px]">
              <h4 className="text-xs uppercase tracking-wider text-loss mb-2">üü¢ Underrepresented (may buy)</h4>
              {topUnder.length === 0 ? <p className="text-muted-foreground text-sm">None</p> : 
                topUnder.map(d => <div key={d.digit} className="flex justify-between items-center text-sm py-1 border-b border-border/50"><span className="font-mono">Digit {d.digit}</span><span className="text-loss font-mono">{d.dev.toFixed(1)}%</span></div>)}
            </div>
          </div>
        </AnalysisCard>
      );
    }

    // ---------- Signal Scanner Component (uses last 1000 ticks internally) ----------
    function SignalScanner({ digits, lastDigit }) {
      const [scannerActive, setScannerActive] = useState(false);
      const [lastSignal, setLastSignal] = useState(null);
      const W = 1000; // window size

      const prediction = useMemo(() => {
        const len = digits.length;
        if (len === 0) return null;
        const recentDigits = len <= W ? digits : digits.slice(len - W);
        const counts = Array(10).fill(0);
        recentDigits.forEach(d => counts[d]++);
        const percentages = counts.map(c => (c / recentDigits.length) * 100);
        let maxIdx = 0;
        for (let i = 1; i < 10; i++) {
          if (percentages[i] > percentages[maxIdx]) maxIdx = i;
        }
        const highestPct = percentages[maxIdx];
        const triggerDigit = maxIdx;

        const target1 = highestPct - 0.5;
        let closest1 = 0;
        let minDiff1 = Math.abs(percentages[0] - target1);
        for (let i = 1; i < 10; i++) {
          const diff = Math.abs(percentages[i] - target1);
          if (diff < minDiff1) {
            minDiff1 = diff;
            closest1 = i;
          }
        }
        const firstTargetPct = percentages[closest1];

        const target2 = firstTargetPct - 0.5;
        let closest2 = 0;
        let minDiff2 = Math.abs(percentages[0] - target2);
        for (let i = 1; i < 10; i++) {
          const diff = Math.abs(percentages[i] - target2);
          if (diff < minDiff2) {
            minDiff2 = diff;
            closest2 = i;
          }
        }
        const targetDigit = closest2;

        return { triggerDigit, targetDigit, highestPct, target1, firstTargetPct, target2, targetPct: target2 };
      }, [digits]);

      useEffect(() => {
        if (scannerActive && prediction && lastDigit === prediction.triggerDigit) {
          setLastSignal({ ...prediction, timestamp: Date.now() });
        }
      }, [lastDigit, prediction, scannerActive]);

      const toggleScanner = () => {
        setScannerActive(prev => !prev);
        setLastSignal(null);
      };

      return (
        <AnalysisCard title="üîî Signal Scanner " subtitle="Exact digit prediction is shown below">
          <div className="flex items-center justify-between mb-3">
            <button
              onClick={toggleScanner}
              className={`px-4 py-1.5 rounded text-sm font-semibold transition-colors ${
                scannerActive 
                  ? 'bg-destructive text-destructive-foreground hover:bg-destructive/80' 
                  : 'bg-primary text-primary-foreground hover:bg-primary/80'
              }`}
            >
              {scannerActive ? '‚èπ Stop Scanner' : '‚ñ∂ Start Scanner'}
            </button>
            {scannerActive && <span className="text-xs text-profit animate-pulse">‚óè SCANNING</span>}
          </div>

          {prediction ? (
            <div>
              <p className="text-sm">
                <span className="text-muted-foreground">Highest digit:</span>{' '}
                <span className="font-bold text-highlight text-lg">{prediction.triggerDigit}</span>{' '}
                <span className="text-muted-foreground">({prediction.highestPct.toFixed(1)}%)</span>
              </p>
              <p className="text-sm mt-1">
                <span className="text-muted-foreground">Exact scanned is:</span>{' '}
                <span className="font-bold text-profit text-lg">{prediction.targetDigit}</span>{' '}
                <span className="text-muted-foreground">(probability {prediction.targetPct.toFixed(1)}%)</span>
              </p>
              {lastSignal && scannerActive && (
                <div className="mt-3 p-3 bg-profit/20 border border-profit rounded-md animate-pulse">
                  <span className="font-mono text-sm">‚ö° SIGNAL ‚Äî Entry Digit {prediction.triggerDigit} Prediction is {prediction.targetDigit}</span>
                </div>
              )}
            </div>
          ) : (
            <p className="text-muted-foreground">Waiting for enough data...</p>
          )}
        </AnalysisCard>
      );
    }

    // Recent Movements Card (displays R/F/= for last 50 ticks)
    function RecentMovements({ prices }) {
      const getMovement = (index) => {
        if (index === 0 || prices.length < 2) return '‚Äî';
        const prev = prices[index-1];
        const curr = prices[index];
        if (curr > prev) return 'R';
        if (curr < prev) return 'F';
        return '=';
      };

      const last50 = prices.slice(-50).reverse();
      const last50Indices = prices.slice(-50).map((_, idx) => prices.length - 50 + idx).reverse();

      return (
        <AnalysisCard title="üìà Tick Movements (last 50)" subtitle="R=Rise, F=Fall, = =Same, ‚Äî =First tick">
          <div className="flex flex-wrap gap-1.5">
            {last50.map((price, i) => {
              const originalIndex = last50Indices[i];
              const movement = getMovement(originalIndex);
              return (
                <div key={i} className={`w-8 h-8 flex items-center justify-center rounded text-xs font-mono font-bold ${
                  movement === 'R' ? 'bg-profit/15 text-profit' : 
                  movement === 'F' ? 'bg-loss/15 text-loss' : 
                  'bg-secondary text-muted-foreground'
                }`}>
                  {movement}
                </div>
              );
            })}
          </div>
        </AnalysisCard>
      );
    }

    // ---------- Even/Odd Signal Scanner (last 1000 ticks) with configurable threshold and min count ----------
    function EvenOddSignalScanner({ digits, threshold, setThreshold, minCount, setMinCount }) {
      const W = 1000;
      const len = digits.length;
      const recentDigits = len <= W ? digits : digits.slice(len - W);
      const counts = Array(10).fill(0);
      recentDigits.forEach(d => counts[d]++);
      const percentages = counts.map(c => (c / recentDigits.length) * 100);

      const evenDigits = [0,2,4,6,8];
      const oddDigits = [1,3,5,7,9];

      const evenAboveThreshold = evenDigits.filter(d => percentages[d] >= threshold).length;
      const oddAboveThreshold = oddDigits.filter(d => percentages[d] >= threshold).length;

      const signal = useMemo(() => {
        if (evenAboveThreshold >= minCount && oddAboveThreshold >= minCount) {
          return { type: 'BOTH OR IGNORE', message: 'TRADE BOTH OR IGNORE' };
        } else if (evenAboveThreshold >= minCount) {
          return { type: 'ODD', message: 'TRADE ODD' };
        } else if (oddAboveThreshold >= minCount) {
          return { type: 'EVEN', message: 'TRADE EVEN' };
        }
        return null;
      }, [evenAboveThreshold, oddAboveThreshold, minCount]);

      const borderColor = signal?.type === 'EVEN' ? 'border-profit' : signal?.type === 'ODD' ? 'border-loss' : signal?.type === 'BOTH' ? 'border-accent' : 'border-border';

      return (
        <AnalysisCard title="üéØ Even/Odd Signal Scanner" subtitle="Controls just below Even/Odd card">
          {/* Controls moved here */}
          <div className="flex flex-wrap items-center gap-4 mb-4 pb-2 border-b border-border">
            <div className="flex items-center gap-2">
              <label className="text-xs text-muted-foreground">Threshold %:</label>
              <input
                type="number"
                value={threshold}
                onChange={(e) => setThreshold(parseFloat(e.target.value))}
                step="0.1"
                min="0"
                max="100"
                className="bg-secondary border border-border rounded px-2 py-1 text-sm font-mono text-foreground w-20 focus:outline-none focus:ring-1 focus:ring-primary"
              />
            </div>
            <div className="flex items-center gap-2">
              <label className="text-xs text-muted-foreground">Min digits:</label>
              <input
                type="number"
                value={minCount}
                onChange={(e) => setMinCount(parseInt(e.target.value))}
                step="1"
                min="1"
                max="5"
                className="bg-secondary border border-border rounded px-2 py-1 text-sm font-mono text-foreground w-16 focus:outline-none focus:ring-1 focus:ring-primary"
              />
            </div>
          </div>

          <div className={`p-4 rounded-lg border-4 ${borderColor} transition-colors duration-300`}>
            {signal ? (
              <div className="text-center">
                <span className="text-2xl font-bold">{signal.message}</span>
              </div>
            ) : (
              <div className="text-center text-muted-foreground">
                No signal yet
              </div>
            )}
            <div className="mt-2 text-xs text-muted-foreground text-center">
              Even digits ‚â•{threshold.toFixed(1)}%: {evenAboveThreshold} | Odd digits ‚â•{threshold.toFixed(1)}%: {oddAboveThreshold}
            </div>
          </div>
        </AnalysisCard>
      );
    }

    // ---------- Trade Predictions Panel ----------
    function TradePredictions({ frequency, overUnder, evenOdd, riseFall }) {
      if (!frequency || frequency.length === 0) return null;

      const getConfidence = (dev) => {
        const absDev = Math.abs(dev);
        if (absDev >= 5) return { label: 'HIGH', color: 'text-profit' };
        if (absDev >= 2) return { label: 'MEDIUM', color: 'text-yellow-400' };
        return { label: 'LOW', color: 'text-muted-foreground' };
      };

      const deviations = frequency.map(f => ({ digit: f.digit, dev: f.percentage - 10 }));
      const sorted = [...deviations].sort((a, b) => Math.abs(b.dev) - Math.abs(a.dev));
      const topOver = sorted.filter(d => d.dev > 0)[0];
      const topUnder = sorted.filter(d => d.dev < 0)[0];

      let bestOverUnder = null;
      let maxOverUnderDev = 0;
      overUnder.forEach(row => {
        const expectedOver = (9 - row.digit) / 10 * 100;
        const expectedUnder = row.digit / 10 * 100;
        const overDev = row.overPercentage - expectedOver;
        const underDev = row.underPercentage - expectedUnder;
        if (Math.abs(overDev) > Math.abs(maxOverUnderDev)) {
          maxOverUnderDev = overDev;
          bestOverUnder = { type: 'OVER', digit: row.digit, dev: overDev, actual: row.overPercentage, expected: expectedOver };
        }
        if (Math.abs(underDev) > Math.abs(maxOverUnderDev)) {
          maxOverUnderDev = underDev;
          bestOverUnder = { type: 'UNDER', digit: row.digit, dev: underDev, actual: row.underPercentage, expected: expectedUnder };
        }
      });

      const evenDev = evenOdd.evenPercentage - 50;
      const oddDev = evenOdd.oddPercentage - 50;
      const evenOddBest = Math.abs(evenDev) >= Math.abs(oddDev) ? 
        { type: 'EVEN', dev: evenDev, actual: evenOdd.evenPercentage } : 
        { type: 'ODD', dev: oddDev, actual: evenOdd.oddPercentage };

      const riseDev = riseFall.risePercent - 50;
      const fallDev = riseFall.fallPercent - 50;
      const riseFallBest = Math.abs(riseDev) >= Math.abs(fallDev) ? 
        { type: 'RISE', dev: riseDev, actual: riseFall.risePercent } : 
        { type: 'FALL', dev: fallDev, actual: riseFall.fallPercent };

      return (
        <AnalysisCard title="üìâ Trade Predictions" subtitle="Best contracts based on statistical deviation (last 1000 ticks)">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="bg-secondary rounded-lg p-3">
              <h4 className="text-xs uppercase tracking-wider text-highlight mb-2">Matches / Differs</h4>
              {topOver && (
                <div className="flex justify-between items-center text-sm py-1">
                  <span className="font-mono">Digit {topOver.digit} (over)</span>
                  <span className="font-mono text-profit">+{topOver.dev.toFixed(1)}%</span>
                  <span className={`text-xs font-bold ${getConfidence(topOver.dev).color}`}>{getConfidence(topOver.dev).label}</span>
                </div>
              )}
              {topUnder && (
                <div className="flex justify-between items-center text-sm py-1">
                  <span className="font-mono">Digit {topUnder.digit} (under)</span>
                  <span className="font-mono text-loss">{topUnder.dev.toFixed(1)}%</span>
                  <span className={`text-xs font-bold ${getConfidence(topUnder.dev).color}`}>{getConfidence(topUnder.dev).label}</span>
                </div>
              )}
            </div>

            {bestOverUnder && (
              <div className="bg-secondary rounded-lg p-3">
                <h4 className="text-xs uppercase tracking-wider text-highlight mb-2">Over / Under</h4>
                <div className="flex justify-between items-center text-sm py-1">
                  <span className="font-mono">Barrier {bestOverUnder.digit} {bestOverUnder.type}</span>
                  <span className={`font-mono ${bestOverUnder.dev > 0 ? 'text-profit' : 'text-loss'}`}>
                    {bestOverUnder.dev > 0 ? '+' : ''}{bestOverUnder.dev.toFixed(1)}%
                  </span>
                  <span className={`text-xs font-bold ${getConfidence(bestOverUnder.dev).color}`}>{getConfidence(bestOverUnder.dev).label}</span>
                </div>
              </div>
            )}

            <div className="bg-secondary rounded-lg p-3">
              <h4 className="text-xs uppercase tracking-wider text-highlight mb-2">Even / Odd</h4>
              <div className="flex justify-between items-center text-sm py-1">
                <span className="font-mono">{evenOddBest.type}</span>
                <span className={`font-mono ${evenOddBest.dev > 0 ? 'text-profit' : 'text-loss'}`}>
                  {evenOddBest.dev > 0 ? '+' : ''}{evenOddBest.dev.toFixed(1)}%
                </span>
                <span className={`text-xs font-bold ${getConfidence(evenOddBest.dev).color}`}>{getConfidence(evenOddBest.dev).label}</span>
              </div>
            </div>

            <div className="bg-secondary rounded-lg p-3">
              <h4 className="text-xs uppercase tracking-wider text-highlight mb-2">Rise / Fall</h4>
              <div className="flex justify-between items-center text-sm py-1">
                <span className="font-mono">{riseFallBest.type}</span>
                <span className={`font-mono ${riseFallBest.dev > 0 ? 'text-profit' : 'text-loss'}`}>
                  {riseFallBest.dev > 0 ? '+' : ''}{riseFallBest.dev.toFixed(1)}%
                </span>
                <span className={`text-xs font-bold ${getConfidence(riseFallBest.dev).color}`}>{getConfidence(riseFallBest.dev).label}</span>
              </div>
            </div>
          </div>
        </AnalysisCard>
      );
    }

    // ---------- Range Dominance Scanner (0-4 vs 5-9) with 1.2% threshold ----------
    function RangeDominanceScanner({ digits }) {
      const W = 1000;
      const N = 90; // expected ticks in 30s
      const len = digits.length;
      if (len === 0) return null;

      const recentDigits = len <= W ? digits : digits.slice(len - W);
      const counts = Array(10).fill(0);
      recentDigits.forEach(d => counts[d]++);
      const windowSize = recentDigits.length;

      // Probabilities for each digit
      const P = counts.map(c => c / windowSize);

      // Sum for ranges 0-4 and 5-9
      const P04 = P.slice(0, 5).reduce((a, b) => a + b, 0);
      const P59 = P.slice(5, 10).reduce((a, b) => a + b, 0);

      // Expected counts in next 30s
      const E04 = P04 * N;
      const E59 = P59 * N;

      // Dominance D = |P04 - 0.5|
      const D = Math.abs(P04 - 0.5);

      // Determine signal with 1.2% threshold
      const threshold = 0.012;
      const hasSignal = D >= threshold;

      let signalType = null;
      let message = '';
      if (hasSignal) {
        if (P04 > 0.5) {
          signalType = 'UNDER_5';
          message = `üü¢ 0‚Äì4 dominance expected (${E04.toFixed(1)} vs ${E59.toFixed(1)} appearances) ‚Äì Trade: Digit Under 7/6/5`;
        } else {
          signalType = 'OVER_4';
          message = `üü¢ 5‚Äì9 dominance expected (${E59.toFixed(1)} vs ${E04.toFixed(1)} appearances) ‚Äì Trade: Digit Over 2/3/4`;
        }
      }

      return (
        <AnalysisCard title="üìä Range Dominance Scanner (0-4 vs 5-9)" subtitle="Predicts which digit range will dominate in next 30s">
          <div className="space-y-3">
            <div className="flex justify-between text-sm">
              <span className="text-muted-foreground">P(0-4):</span>
              <span className="font-mono">{(P04*100).toFixed(1)}%</span>
            </div>
            <div className="flex justify-between text-sm">
              <span className="text-muted-foreground">P(5-9):</span>
              <span className="font-mono">{(P59*100).toFixed(1)}%</span>
            </div>
            <div className="flex justify-between text-sm">
              <span className="text-muted-foreground">Dominance D:</span>
              <span className="font-mono">{(D*100).toFixed(1)}%</span>
            </div>
            <div className="flex justify-between text-sm">
              <span className="text-muted-foreground">Expected 0-4 in 30s:</span>
              <span className="font-mono">{E04.toFixed(1)} ticks</span>
            </div>
            <div className="flex justify-between text-sm">
              <span className="text-muted-foreground">Expected 5-9 in 30s:</span>
              <span className="font-mono">{E59.toFixed(1)} ticks</span>
            </div>

            <div className={`mt-3 p-3 rounded-lg border-2 text-center ${hasSignal ? (P04 > 0.5 ? 'border-profit bg-profit/10' : 'border-accent bg-accent/10') : 'border-border bg-secondary/50'}`}>
              {hasSignal ? (
                <span className="font-bold">{message}</span>
              ) : (
                <span className="text-muted-foreground">üî¥ NO SIGNAL ‚Äì market too balanced (D &lt; 1.2%)</span>
              )}
            </div>

            <div className="text-xs text-muted-foreground border-t border-border pt-2">
              Based on last {windowSize} ticks | N=90 ticks (‚âà30s) | threshold 1.2%
            </div>
          </div>
        </AnalysisCard>
      );
    }

    // ---------- AI-Enhanced Digit Prediction Component ----------
    function AIPrediction({ digits }) {
      const [lastDigit, setLastDigit] = useState(null);
      useEffect(() => {
        if (digits.length > 0) setLastDigit(digits[digits.length - 1]);
      }, [digits]);

      const prediction = useMemo(() => {
        const len = digits.length;
        if (len < 100) return null; // need at least 100 ticks for micro window

        // Helper to get counts for a window size
        const getCounts = (windowSize) => {
          const start = Math.max(0, len - windowSize);
          const slice = digits.slice(start, len);
          const counts = Array(10).fill(0);
          slice.forEach(d => counts[d]++);
          return counts;
        };

        const counts100 = getCounts(100);
        const counts500 = getCounts(500);
        const counts1000 = getCounts(1000);

        const total100 = Math.min(100, len);
        const total500 = Math.min(500, len);
        const total1000 = Math.min(1000, len);

        // Weighted frequency score per digit
        const weighted = Array(10).fill(0);
        for (let i = 0; i < 10; i++) {
          weighted[i] = 0.5 * (counts100[i] / total100) + 0.3 * (counts500[i] / total500) + 0.2 * (counts1000[i] / total1000);
        }

        // Entropy using last 1000 ticks
        const p = counts1000.map(c => c / total1000);
        let entropy = 0;
        for (let i = 0; i < 10; i++) {
          if (p[i] > 0) entropy -= p[i] * Math.log(p[i]);
        }
        const entropyOk = entropy < 2.25;

        // Transition matrix from last 1000 ticks
        const transition = Array(10).fill(null).map(() => Array(10).fill(0));
        const transCounts = Array(10).fill(null).map(() => Array(10).fill(0));
        const startIdx = Math.max(0, len - 1000);
        for (let i = startIdx; i < len - 1; i++) {
          const from = digits[i];
          const to = digits[i + 1];
          transCounts[from][to]++;
        }
        for (let from = 0; from < 10; from++) {
          const totalFrom = transCounts[from].reduce((a, b) => a + b, 0);
          if (totalFrom > 0) {
            for (let to = 0; to < 10; to++) {
              transition[from][to] = transCounts[from][to] / totalFrom;
            }
          } else {
            // if no transitions, assume uniform? But we'll just keep zeros.
          }
        }

        // Final score = weighted * transition from last digit
        const finalScore = Array(10).fill(0);
        if (lastDigit !== null) {
          const trans = transition[lastDigit];
          for (let j = 0; j < 10; j++) {
            finalScore[j] = weighted[j] * (trans[j] || 0); // if no transition, zero
          }
        } else {
          // fallback to weighted only
          for (let j = 0; j < 10; j++) {
            finalScore[j] = weighted[j];
          }
        }

        const maxScore = Math.max(...finalScore);
        const meanScore = finalScore.reduce((a, b) => a + b, 0) / 10;
        const confidence = maxScore - meanScore;
        const confidenceOk = confidence >= 0.04;

        // Determine best contract
        let tradeType = 'WAIT';
        let target = null;
        if (entropyOk && confidenceOk) {
          // Check conditions in order
          // 1. Any digit > 18% in weighted frequency?
          for (let i = 0; i < 10; i++) {
            if (weighted[i] > 0.18) {
              tradeType = `Match Digit ${i}`;
              target = i;
              break;
            }
          }
          if (tradeType === 'WAIT') {
            // 2. Even sum > 55%
            const evenSum = weighted[0] + weighted[2] + weighted[4] + weighted[6] + weighted[8];
            if (evenSum > 0.55) {
              tradeType = 'Even';
            }
            // 3. Odd sum > 55%
            else {
              const oddSum = weighted[1] + weighted[3] + weighted[5] + weighted[7] + weighted[9];
              if (oddSum > 0.55) {
                tradeType = 'Odd';
              }
              else {
                // 4. Max digit in 0-4
                const maxDigit = finalScore.indexOf(maxScore);
                if (maxDigit <= 4) {
                  tradeType = 'Digit Under 5';
                } else {
                  tradeType = 'Digit Over 4';
                }
              }
            }
          }
        }

        return {
          weighted,
          entropy: entropy.toFixed(3),
          entropyOk,
          confidence: confidence.toFixed(4),
          confidenceOk,
          tradeType,
          finalScore,
        };
      }, [digits, lastDigit]);

      if (!prediction) {
        return (
          <AnalysisCard title="üß† AI-Enhanced Digit Prediction" subtitle="Waiting for enough data (‚â•100 ticks)">
            <div className="text-center text-muted-foreground py-4">Collecting data...</div>
          </AnalysisCard>
        );
      }

      return (
        <AnalysisCard title="üß† AI-Enhanced Digit Prediction" subtitle="Multi‚Äëwindow + entropy + transitions + confidence gate">
          <div className="space-y-3">
            <div className="grid grid-cols-2 gap-2 text-sm">
              <div>
                <span className="text-muted-foreground">Entropy: </span>
                <span className={prediction.entropyOk ? 'text-profit' : 'text-loss'}>
                  {prediction.entropy} {prediction.entropyOk ? '‚úì' : '‚úó'}
                </span>
              </div>
              <div>
                <span className="text-muted-foreground">Confidence: </span>
                <span className={prediction.confidenceOk ? 'text-profit' : 'text-loss'}>
                  {prediction.confidence} {prediction.confidenceOk ? '‚úì' : '‚úó'}
                </span>
              </div>
            </div>
            <div className="text-center text-lg font-bold">
              {prediction.tradeType === 'WAIT' ? (
                <span className="text-yellow-400">‚è≥ WAIT</span>
              ) : (
                <span className="text-profit">‚úÖ {prediction.tradeType}</span>
              )}
            </div>
            <div className="text-xs text-muted-foreground">
              Weighted scores: {prediction.weighted.map((w, i) => `${i}:${(w*100).toFixed(1)}%`).join('  ')}
            </div>
          </div>
        </AnalysisCard>
      );
    }

    // ---------- Even/Odd Momentum Scanner ----------
    function EvenOddMomentum({ frequency1000 }) {
      const [history, setHistory] = useState([]);
      const THRESHOLD = 3.0; // percentage points
      const WINDOW_SIZE = 10; // number of ticks to compare

      // Compute current even percentage from frequency1000
      const evenPercentage = useMemo(() => {
        if (!frequency1000 || frequency1000.length === 0) return 0;
        const evenDigits = [0,2,4,6,8];
        let sum = 0;
        evenDigits.forEach(d => {
          const found = frequency1000.find(f => f.digit === d);
          if (found) sum += found.percentage;
        });
        return sum;
      }, [frequency1000]);

      // Update history when evenPercentage changes
      useEffect(() => {
        setHistory(prev => {
          const newHistory = [...prev, evenPercentage];
          if (newHistory.length > WINDOW_SIZE) {
            newHistory.shift();
          }
          return newHistory;
        });
      }, [evenPercentage]);

      // Calculate change from oldest to newest
      const delta = useMemo(() => {
        if (history.length < WINDOW_SIZE) return null;
        const oldest = history[0];
        const newest = history[history.length - 1];
        return newest - oldest;
      }, [history]);

      const signal = useMemo(() => {
        if (delta === null || Math.abs(delta) < THRESHOLD) return null;
        if (delta > 0) {
          return { direction: 'even', message: `üìà Even gaining momentum (+${delta.toFixed(1)}% over last ${WINDOW_SIZE} ticks) ‚Äì Possible shift to EVEN` };
        } else {
          return { direction: 'odd', message: `üìâ Odd gaining momentum (${delta.toFixed(1)}% over last ${WINDOW_SIZE} ticks) ‚Äì Possible shift to ODD` };
        }
      }, [delta]);

      const borderColor = signal?.direction === 'even' ? 'border-profit' : signal?.direction === 'odd' ? 'border-loss' : 'border-border';

      return (
        <AnalysisCard title="‚ö° Even/Odd Momentum" subtitle={`Tracks even % change over last ${WINDOW_SIZE} ticks (threshold ${THRESHOLD}%)`}>
          <div className="space-y-2">
            <div className="flex justify-between text-sm">
              <span className="text-muted-foreground">Current Even %:</span>
              <span className="font-mono">{evenPercentage.toFixed(1)}%</span>
            </div>
            {delta !== null && (
              <div className="flex justify-between text-sm">
                <span className="text-muted-foreground">Change (last {WINDOW_SIZE} ticks):</span>
                <span className={`font-mono ${delta > 0 ? 'text-profit' : 'text-loss'}`}>
                  {delta > 0 ? '+' : ''}{delta.toFixed(1)}%
                </span>
              </div>
            )}
            <div className={`mt-2 p-3 rounded-lg border-2 text-center ${borderColor} ${signal ? (signal.direction === 'even' ? 'bg-profit/10' : 'bg-loss/10') : 'bg-secondary/50'}`}>
              {signal ? (
                <span className="font-bold">{signal.message}</span>
              ) : (
                <span className="text-muted-foreground">No significant momentum (|Œî| &lt; {THRESHOLD}%)</span>
              )}
            </div>
          </div>
        </AnalysisCard>
      );
    }

    // ---------- main App ----------
    function Index() {
      // Theme state: 'dark', 'light', or 'system'
      const [theme, setTheme] = useState(() => {
        // Check localStorage or default to 'system'
        const saved = localStorage.getItem('theme');
        return saved ? saved : 'system';
      });

      // Apply theme to body class
      useEffect(() => {
        const applyTheme = (mode) => {
          const body = document.body;
          if (mode === 'dark') {
            body.classList.remove('light-theme');
          } else if (mode === 'light') {
            body.classList.add('light-theme');
          } else if (mode === 'system') {
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (prefersDark) {
              body.classList.remove('light-theme');
            } else {
              body.classList.add('light-theme');
            }
          }
          localStorage.setItem('theme', mode);
        };

        applyTheme(theme);

        // Listen for system theme changes if theme is 'system'
        if (theme === 'system') {
          const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
          const handler = (e) => {
            if (e.matches) {
              document.body.classList.remove('light-theme');
            } else {
              document.body.classList.add('light-theme');
            }
          };
          mediaQuery.addEventListener('change', handler);
          return () => mediaQuery.removeEventListener('change', handler);
        }
      }, [theme]);

      const [maxTicks, setMaxTicks] = useState(1000);
      const [inputValue, setInputValue] = useState("1000");
      const [digits, setDigits] = useState([]);
      const [prices, setPrices] = useState([]);
      const [symbol, setSymbol] = useState("R_100");
      const [isLive, setIsLive] = useState(false);
      const [lastPrice, setLastPrice] = useState(null);
      const [decimalPlaces, setDecimalPlaces] = useState(3);
      const connectionRef = useRef(null);

      // Configurable parameters for Even/Odd scanner
      const [threshold, setThreshold] = useState(10.2);
      const [minCount, setMinCount] = useState(3);

      const [freqHistory, setFreqHistory] = useState([]);
      const lastSnapshotLength = useRef(0);

      useEffect(() => {
        let active = true;
        const load = async () => {
          const dp = await fetchDecimalPlaces(symbol);
          if (active) setDecimalPlaces(dp);
        };
        load();
        return () => { active = false; };
      }, [symbol]);

      useEffect(() => {
        if (digits.length === 0) return;
        if (digits.length % 10 === 0 && digits.length > lastSnapshotLength.current) {
          lastSnapshotLength.current = digits.length;
          const freqs = computeDigitFrequency(digits).map(f => f.percentage);
          setFreqHistory(prev => {
            const updated = [...prev, freqs];
            return updated.slice(-30);
          });
        }
      }, [digits]);

      const resetHistory = useCallback(() => {
        setFreqHistory([]);
        lastSnapshotLength.current = 0;
      }, []);

      const frequency1000 = useMemo(() => computeFrequency1000(digits), [digits]);
      const overUnder = useMemo(() => computeOverUnder(digits), [digits]);
      const matchDiffer = useMemo(() => computeMatchDiffer(digits), [digits]);
      const evenOdd = useMemo(() => computeEvenOdd(digits), [digits]);
      const riseFall = useMemo(() => computeRiseFall(prices), [prices]);

      const startStream = useCallback(() => {
        if (connectionRef.current) connectionRef.current.disconnect();
        setDigits([]);
        setPrices([]);
        setLastPrice(null);
        resetHistory();
        const conn = connectDeriv();
        connectionRef.current = conn;
        setIsLive(true);

        conn.subscribe(symbol, (rawPrice) => {
          const formatted = rawPrice.toFixed(decimalPlaces);
          const digit = getLastDigitFromPrice(formatted);
          setLastPrice(formatted);
          setDigits(prev => {
            const next = [...prev, digit];
            return next.length > maxTicks ? next.slice(next.length - maxTicks) : next;
          });
          setPrices(prev => {
            const next = [...prev, rawPrice];
            return next.length > maxTicks ? next.slice(next.length - maxTicks) : next;
          });
        });
      }, [symbol, maxTicks, resetHistory, decimalPlaces]);

      const stopStream = useCallback(() => {
        connectionRef.current?.disconnect();
        connectionRef.current = null;
        setIsLive(false);
      }, []);

      useEffect(() => {
        return () => connectionRef.current?.disconnect();
      }, []);

      const handleMaxTicksChange = () => {
        const count = Math.max(10, Math.min(50000, parseInt(inputValue) || 1000));
        setMaxTicks(count);
        setInputValue(String(count));
        setDigits(prev => (prev.length > count ? prev.slice(prev.length - count) : prev));
        setPrices(prev => (prev.length > count ? prev.slice(prev.length - count) : prev));
        resetHistory();
      };

      const selectedLabel = VOLATILITY_SYMBOLS.find(s => s.value === symbol)?.label || symbol;
      const currentDigit = digits.length > 0 ? digits[digits.length - 1] : null;

      const currentStreak = useMemo(() => {
        if (digits.length === 0) return 0;
        let streak = 1;
        for (let i = digits.length - 2; i >= 0; i--) {
          if (digits[i] === digits[digits.length - 1]) streak++;
          else break;
        }
        return streak;
      }, [digits]);

      const getStreakColor = (streak) => {
        if (streak === 1) return 'text-profit';
        if (streak === 2) return 'text-white';
        if (streak === 3) return 'text-blue-400';
        if (streak === 4) return 'text-yellow-400';
        if (streak >= 5) return 'text-purple-400';
        return 'text-profit';
      };

      const recentDigits = useMemo(() => digits.slice(-50).reverse(), [digits]);
      const consecutiveFlags = useMemo(() => {
        const flags = new Array(recentDigits.length).fill(false);
        for (let i = 0; i < recentDigits.length; i++) {
          if (i > 0 && recentDigits[i] === recentDigits[i-1]) {
            flags[i] = true;
            flags[i-1] = true;
          }
        }
        return flags;
      }, [recentDigits]);

      const windowSizeDisplay = digits.length < 1000 ? digits.length : 1000;

      // Determine highest and lowest percentages for circles
      const percentages = frequency1000.map(f => f.percentage);
      const maxPct = percentages.length ? Math.max(...percentages) : 0;
      const minPct = percentages.length ? Math.min(...percentages) : 0;
      const hasRange = maxPct > minPct;

      // Split digits into two groups
      const upperDigits = frequency1000.filter(f => f.digit <= 4);
      const lowerDigits = frequency1000.filter(f => f.digit >= 5);

      return (
        <div className="min-h-screen bg-background">
          <header className="border-b border-border px-6 py-4">
            <div className="max-w-7xl mx-auto flex items-center justify-between flex-wrap gap-3">
              <div>
                <h1 className="text-xl font-bold text-foreground tracking-tight"><span className="text-primary">‚óè</span> Trading Analysis</h1>
                <p className="text-xs text-muted-foreground mt-0.5">Deriv Synthetic Indices ‚Äî Live Digit Analysis</p>
              </div>
              <div className="flex items-center gap-3 text-xs font-mono">
                {isLive && <span className="flex items-center gap-1.5 text-profit"><span className="animate-pulse-glow">‚óè</span> LIVE</span>}
                <span className="text-muted-foreground">{digits.length.toLocaleString()} ticks</span>
                {lastPrice && <span className="text-highlight font-semibold">{lastPrice}</span>}
              </div>
            </div>
          </header>

          <main className="max-w-7xl mx-auto px-6 py-6 space-y-6">
            <div className="bg-card border border-border rounded-lg p-4 flex flex-wrap items-center gap-4">
              <div className="flex items-center gap-2">
                <label className="text-sm text-muted-foreground">Symbol:</label>
                <select value={symbol} onChange={e => setSymbol(e.target.value)} disabled={isLive} className="bg-secondary border border-border rounded px-3 py-1.5 text-sm font-mono text-foreground focus:outline-none focus:ring-1 focus:ring-primary disabled:opacity-50">
                  {VOLATILITY_SYMBOLS.map(s => <option key={s.value} value={s.value}>{s.label}</option>)}
                </select>
              </div>
              <div className="flex items-center gap-2">
                <label className="text-sm text-muted-foreground">Max ticks:</label>
                <input type="number" value={inputValue} onChange={e => setInputValue(e.target.value)} onKeyDown={e => e.key === "Enter" && handleMaxTicksChange()} onBlur={handleMaxTicksChange} min={10} max={50000} className="bg-secondary border border-border rounded px-3 py-1.5 text-sm font-mono text-foreground w-24 focus:outline-none focus:ring-1 focus:ring-primary" />
              </div>

              {/* Theme selector */}
              <div className="flex items-center gap-2">
                <label className="text-sm text-muted-foreground">Theme:</label>
                <select
                  value={theme}
                  onChange={(e) => setTheme(e.target.value)}
                  className="bg-secondary border border-border rounded px-3 py-1.5 text-sm font-mono text-foreground focus:outline-none focus:ring-1 focus:ring-primary"
                >
                  <option value="dark">Dark</option>
                  <option value="light">Light</option>
                  <option value="system">System</option>
                </select>
              </div>

              <div className="flex gap-2 ml-auto">
                {!isLive ? <button onClick={startStream} className="bg-primary text-primary-foreground px-5 py-1.5 rounded text-sm font-semibold hover:opacity-90 transition-opacity">‚ñ∂ Start Live</button> :
                <button onClick={stopStream} className="bg-destructive text-destructive-foreground px-5 py-1.5 rounded text-sm font-semibold hover:opacity-90 transition-opacity">‚ñ† Stop</button>}
              </div>
            </div>

            {digits.length === 0 && !isLive && (
              <div className="bg-card border border-border rounded-lg p-12 text-center">
                <p className="text-muted-foreground text-lg mb-2">Select a symbol and click <strong className="text-primary">Start Live</strong> to begin</p>
                <p className="text-muted-foreground text-sm">Real-time tick data from Deriv's synthetic indices</p>
              </div>
            )}

            {digits.length > 0 && (
              <>
                <AnalysisCard title="Digit Frequency" subtitle={`${selectedLabel} ‚Äî last ${windowSizeDisplay} ticks (expected 10.0% each)`}>
                  <div className="flex flex-col items-center space-y-4">
                    {/* Upper row: digits 0-4 */}
                    <div className="flex justify-center flex-wrap gap-2">
                      {upperDigits.map((f) => (
                        <DigitCircle
                          key={f.digit}
                          digit={f.digit}
                          percentage={f.percentage}
                          isHighest={hasRange && f.percentage === maxPct}
                          isLowest={hasRange && f.percentage === minPct}
                          isCurrent={currentDigit === f.digit}
                        />
                      ))}
                    </div>
                    {/* Lower row: digits 5-9 */}
                    <div className="flex justify-center flex-wrap gap-2">
                      {lowerDigits.map((f) => (
                        <DigitCircle
                          key={f.digit}
                          digit={f.digit}
                          percentage={f.percentage}
                          isHighest={hasRange && f.percentage === maxPct}
                          isLowest={hasRange && f.percentage === minPct}
                          isCurrent={currentDigit === f.digit}
                        />
                      ))}
                    </div>
                  </div>
                </AnalysisCard>

                {/* Range Dominance Scanner with 1.2% threshold */}
                <RangeDominanceScanner digits={digits} />

                {/* AI Prediction Card */}
                <AIPrediction digits={digits} />

                <SuggestionCard frequency={frequency1000} />

                <SignalScanner digits={digits} lastDigit={currentDigit} />

                {/* Large last digit display with dynamic color based on streak */}
                <div className="text-6xl md:text-7xl font-bold text-center py-4 border border-profit/30 rounded-lg bg-profit/5">
                  <span className={getStreakColor(currentStreak)}>
                    {lastPrice ? getLastDigitFromPrice(lastPrice) : '--'}
                  </span>
                </div>
                <div className="text-xs text-muted-foreground text-center mt-1">
                  Last Digit {currentStreak > 1 ? `(streak: ${currentStreak})` : ''}
                </div>

                <RiseFallCard data={riseFall} />

                <RecentMovements prices={prices} />

                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                  <AnalysisCard 
                    title="Over / Under" 
                    subtitle={`Probability per digit barrier ‚Äî Current price: ${lastPrice ? lastPrice : '--'}`}
                  >
                    <OverUnderTable data={overUnder} />
                  </AnalysisCard>

                  <AnalysisCard 
                    title="Matches / Differs" 
                    subtitle={`Match & differ probability per digit ‚Äî Current price: ${lastPrice ? lastPrice : '--'}`}
                  >
                    <MatchDifferTable data={matchDiffer} />
                  </AnalysisCard>

                  <AnalysisCard 
                    title="Even / Odd" 
                    subtitle={`Even vs odd distribution ‚Äî Current price: ${lastPrice ? lastPrice : '--'}`}
                  >
                    <EvenOddDisplay data={evenOdd} />
                  </AnalysisCard>
                </div>

                {/* Even/Odd Signal Scanner with controls inside, placed right after the Even/Odd card */}
                <EvenOddSignalScanner
                  digits={digits}
                  threshold={threshold}
                  setThreshold={setThreshold}
                  minCount={minCount}
                  setMinCount={setMinCount}
                />

                {/* Even/Odd Momentum Scanner - placed below Even/Odd Signal Scanner */}
                <EvenOddMomentum frequency1000={frequency1000} />

                <AnalysisCard title="Recent Digits" subtitle="Last 50 ticks (newest first) ‚Äî Yellow ring indicates consecutive same digit">
                  <div className="flex flex-wrap gap-1.5">
                    {recentDigits.map((d, i) => (
                      <span key={i} className={`w-8 h-8 flex items-center justify-center rounded text-xs font-mono font-bold 
                        ${d % 2 === 0 ? "bg-profit/15 text-profit" : "bg-loss/15 text-loss"}
                        ${consecutiveFlags[i] ? "ring-2 ring-yellow-400 ring-inset" : ""}
                      `}>
                        {d}
                      </span>
                    ))}
                  </div>
                </AnalysisCard>

                <TradePredictions frequency={frequency1000} overUnder={overUnder} evenOdd={evenOdd} riseFall={riseFall} />
              </>
            )}
          </main>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Index />);
  </script>
</body>
</html>
